<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<title>Python kóstoló</title>
<style>
  h3   { color: blue; }
  h4   { color: green; }
  body { text-align:justify; margin: 15px 25px 30px 15px; background-color: #F5F5DC; font-family: Arial; font-size: 14; }
  p { margin: 8px 0; }
  pre { color: blue; margin: 8px 8px 8px 20px; }
  code { background-color: black; color: white; padding-left: 3px; padding-right: 3px;  border-radius: 3px; }
  .code_2 { background-color: lightgray; padding-left: 3px; padding-right: 3px;  border-radius: 3px; }
  .pale { color: gray; }
  .nopale { color: blue; }
  .result { color: olivedrab;  margin-top: -10px;  margin-bottom: -10px; }
  .contents { margin-left:30%; color:red; font-size: 120%; }
  .data { color:green; }
  .emph_1 { color: red; font-weight: bold; }
  .emph_2 { color: green; font-weight: bold; }
  .emph_4 { color: gray; font-family: courier new; letter-spacing: 0.1em; }
  .big_red { color:red; font-size:120%; font-weight:bold; margin-top:-5px; margin-bottom:-17px; } /* for div in text */
  .big_black { color:black; font-size:120%; font-weight:bold; margin-top:-5px; margin-bottom:-17px; } /* for div in text */

  .deleted { text-decoration: line-through; color: blue; }
  .question  { font-family:Cooper Black; color:indigo; }
  .sol_button { color:indigo; font-size: 110%; }
  .solution { display:none; border: 1px groove black; border-radius: 5px; margin: 10px 20px 5px 20px; padding: 5px; background-color: palegoldenrod; }
  .emph_box_1 { margin: 20 auto;padding:10px 20px; background-color: #B1BBBA; border: 1px solid black; border-radius: 4px; text-align: center; font-size: 120%; }
  .blq_1  { border-left: 3px solid #FC4;padding-left: 16px; font-family: Georgia; font-style: italic; }
</style>
</head>
<body>
<div style='font-size: 90%; color: blueviolet'>
<span style='float:right;font-style:italic;'>Nemes Mihály &bull; Mihaly.Nemes@t-systems.com</span>
<p style="text-align:center;">&mdash; Utolsó módosítás: 2020.11.29 &mdash;</p>
</div>

<h1 style='text-align:center;'>Python kóstoló</h1>
<p style='font-size: 150%; text-align: center;'>&nbsp;&nbsp;&#128013;</p>
<p>
<ul class='contents'>
<li><a style='color: red' href='#apologizing'>Egy kis magyarázkodás</a></li>
<li><a style='color: red' href='#easy_combine'>Lego jelleg (elemek könnyű kombinálhatósága)</a>
<ul>
<li><a style='color: red' href='#duck_typing'>Polimorfizmus, dinamikus típusok, duck typing</a>
<ul>
<li><a style='color: red' href='#iterator_interface'>Iterátor interfész példák</a></li>
<li><a style='color: red' href='#testability'>Tesztelhetőség</a></li>
<li><a style='color: red' href='#extended_usability'>Kiterjesztett használhatóság</a></li>
</ul>
</li>
<li><a style='color: red' href='#dunder_functions'>Dunder függvények &ndash; a gépezet elrejtése</a></li>
<li><a style='color: red' href='#data_structures'>Sokféle és rugalmas adatszerkezet</a>
<ul>
<li><a style='color: red' href='#misc_type_collections'>Kevert típusok adatszerkezetekben</a></li>
<li><a style='color: red' href='#structured_items'>Strukturált elemek adatszerkezetekben</a></li>
<li><a style='color: red' href='#extended_dict'>Dictionary kulcs bármely fix típus lehet</a></li>
<li><a style='color: red' href='#data_conversions'>Az adatszerkezetek könnyen átalakíthatók egymásba</a></li>
<li><a style='color: red' href='#extendable_types'>Az alap adattípusok bővíthetők</a></li>
</ul>
</li>
</ul>
</li>
<li><a style='color: red' href='#introspection'>Introspekció &ndash; objektum az egész világ</a>
<ul>
<li><a style='color: red' href='#docstrings'>Docstring</a></li>
</ul>
</li>
<li><a style='color: red' href='#tracing'>Jó hibajelzés</a></li>
<li><a style='color: red' href='#enhanced_indexing'>Indexelés kiterjesztése</a>
<ul>
<li><a style='color: red' href='#negative_index'>Negatív indexek</a></li>
<li><a style='color: red' href='#slicing'>Slicing</a></li>
</ul>
</li>
<li><a style='color: red' href='#default_params'>Ügyesen választott default paraméterek</a></li>
<li><a style='color: red' href='#polymorph_params'>Ügyesen választott polimorf paraméterek</a></li>
<li><a style='color: red' href='#concise_constructs'>Néhány tömör nyelvi elem</a></li>
<li><a style='color: red' href='#function_objects'>Függvényobjektumok, funkcionális programozás</a></li>
<li><a style='color: red' href='#generators'>Generátorok, korutinok</a></li>
<li><a style='color: red' href='#useful_functions'>Sok hasznos függvény és metódus</a></li>
<li><a style='color: red' href='#useful_modules'>Sok hasznos modul jól dokumentálva</a></li>
<li><a style='color: red' href='#easy_install'>Könnyű installálás</a></li>
<li><a style='color: red' href='#easy_for_beginners'>Kezdőknek (is) könnyen tanulható</a></li>
<li style='color: black'><a style='color: black' href='#disadvantages'>...és a hátrányok</a> <span style='color: black'>&#9760;</span>
<ul>
<li><a style='color: black' href='#no_typecheck'>Típusellenőrzés hiánya &rarr; futás közben kiderülő hibák</a></li>
<li><a style='color: black' href='#no_declaration'>Deklaráció hiánya &rarr; még futás közben sem kiderülő hibák</a></li>
<li><a style='color: black' href='#no_private'>Nincsenek private és protected elemek</a></li>
<li><a style='color: black' href='#missing_constructs'>Nincs switch és nincs const</a></li>
<li><a style='color: black' href='#low_speed'>Lassúság?</a></li>
</ul>
</li>
</ul>
</p>
<h2 id='apologizing'>Egy kis magyarázkodás</h2>
<p>
Noha a Pythonnal való ismerkedés elején járunk, mégis érdemesnek gondolom áttekinteni, hogy mit tartok a nyelv (és a hozzá kapcsolódó ökoszisztéma) előnyeinek
és hátrányainak, mert hitem szerint így céltudatosabb lehet az ismerkedés, kevésbé fogunk teljesen elveszni a szintaktika tanulmányozásában, jobban és gyorsabban
kirajzolódnak a részleteken túl az egésznek is a körvonalai.
</p>
<p>
Pythonban teljesen kezdők számára biztosan egyes részek távolinak és elvontnak fognak tűnni &ndash; de szerintem akkor is hasznos egy ilyenfajta bemutatás. Újra
és újra vissza fogunk térni ezekre a gondolatokra és egyre világosabbá fognak válni.
</p>
<p>
Nincs mese, a tanulás már csak ilyen iteratív folyamat.
</p>
<h2 id='easy_combine'>Lego jelleg (elemek könnyű kombinálhatósága)</h2>
<p>
A Python számomra leglenyűgözőbb tulajdonsága az, amilyen könnyen és áttekinthetően lehet programrészeket, modulokat egymáshoz illeszteni.
</p>
<h3 id='duck_typing'>&rtrif; Polimorfizmus, dinamikus típusok, duck typing</h3>
<p>
A nyelv nagyon fontos tulajdonsága a dinamikus típusosság. Ez azt jelenti, hogy ha egy függvény felhívja a paraméterként kapott objektumnak valamilyen
metódusát, akkor paraméterként minden olyan objektum szerepelhet, amelyik rendelkezik az illető metódussal.

<pre>
def func(param):
    param.greeting()

class Early():
    def greeting(self):
        print('Good morning')

class Late():
    def greeting(self):
        print('Good evening')

ea = Early()
la = Late()
func(ea)
func(la)
<div class='result'>
# Good morning
# Good evening
</div>
</pre>
Nincs megkötés arra, hogy a <code>param</code> objektum milyen típusú legyen, csak egy dolog fontos: legyen neki greeting() nevű metódusa. A dinamikus
típusosságnak angolul <span class='code_2'>duck typing</span> a neve, ami arra a mondásra utal, hogy ha valami úgy jár és úgy hápog, mint egy kacsa, akkor
az egy kacsa.
</p>
<p>
A dinamikus típusosság óriási rugalmasságot kölcsönöz a nyelvnek, mintegy szabványos csatlakozókkal látja el az elemeket, amitől ezek szabadon
kombinálhatóvá válnak.
</p>
<h4 id='iterator_interface'>&rtrif;&rtrif; Iterátor interfész példák</h4>
<p>
Rendkívül gyakran kell valamilyen elemek sorozatának tagjait egyenként elővennünk. Pythonban így járunk végig
<pre>
<b style='color:black;'>számsorozatot:                 sztringet:               listát vagy tuple-t:        halmazt:</b>
                                                        x = (10,'A',30)
x = range(5)                   x = 'Python'             x = [10,'A',30]             x = {10, 'A', 30}
<span class='emph_1'>for i in x:                    for i in x:              for i in x:                 for i in x:</span>
    print(i,end=' ')               print(i,end=' ')         print(i,end=' ')            print(i,end=' ')
print()                        print()                   print()                    print()
<div class='result'>
# 0 1 2 3 4                    # P y t h o n             # 10 A 30                  # 10 A 30 (a sorrend nem garantált)
</div>
</pre>

<pre>
<b style='color:black;'>szövegfájl sorait:             adatbázistábla sorait:</b>

                               cursor.execute("SELECT * FROM employee")
x = open('demo_1.txt','r')     x = cursor.fetchall()
<span class='emph_1'>for i in x:                    for i in x:</span>
    print(i,end='')                print(i)
<div class='result'>
# line 1                       # (1,'Smith','1990-04-02')
# line 2                       # (2,'Jones','1985-07-11')
</div>
</pre>

Ezek az elemek mind megvalósítják az úgynevezett iterátor interfészt, ezért <b>teljesen egyformán</b> tudjuk megkapni az általuk szolgáltatott adatsorozatot.
Sőt, mi magunk is tudunk írni olyan osztályt, amely megvalósítja ezt az interfészt, ezért az általa szolgáltatott elemeken végig lehet menni egy közönséges for
ciklussal. Példaként vegyünk egy nem túl hasznos, ám annál egyszerűbb osztályt, amely nullától háromig tud számolni:
<pre>
class StupidCounter:
    def __init__(self):
        self.count = 0

    def <span class='emph_1'>__iter__</span>(self):
        self.count = 0
        return self

    def <span class='emph_1'>__next__</span>(self):
        if self.count > 3:
            raise StopIteration

        ret_val = self.count
        self.count += 1
        return ret_val

c = StupidCounter()
<span class='emph_1'>for i in c:</span>
    print(i,end=' ')
print()
<div class='result'>
# 0 1 2 3
</div>
</pre>
A részletekről később majd szó lesz, most csak az a lényeg, hogy ha néhány egyszerű szabályt betartunk, akkor a mi buta kis számlálónkat ugyanúgy tudják
használni a többi programrészek, mint egy listát. Az ő szempontjukból ez egyszerűen csak egy <span class='emph_4'>valami</span>, ami számsorozatot produkál,
ha az <span style='font-family:Comic Sans MS; color:blueviolet;'>iterátor interfész</span> nevű etikett szerint megkérik rá.
</p>
<h4 id='testability'>&rtrif;&rtrif; Tesztelhetőség</h4>
<p>
Többek között a tesztelhetőséget is roppantul javítja a dinamikus típusosság. Ha van például egy függvényünk, amelynek paraméterül egy megnyitott fájl-objektumot
adunk át, hogy abból olvasson sorokat, akkor tesztelhetjük a függvényt akár egy listával is, amelyben sztringek vannak.

<pre>
def func(param):
    for line in param:
        print('I do something with:', line)

f_obj = open('demo_1.txt','r')
func(f_obj)
<div class='result'>
# I do something with: line 1
# I do something with: line 2
</div>

test_data = ['line 1', 'line 2']
func(test_data)
<div class='result'>
# I do something with: line 1
# I do something with: line 2
</div>
</pre>
<h4 id='extended_usability'>&rtrif;&rtrif; Kiterjesztett használhatóság</h4>
<p>
Másrészt nemcsak fájlt, hanem olyan objektumot is átadhatunk paraméterként a függvénynek, amelyik például a webről olvas be adatokat. Vagy egy hálózatból.
Vagy kiáshatja akár a zőldséges kertjéből is, teljesen mindegy, az a lényeg, hogy legyen neki <code>__next__</code> metódusa, aminek hatására szolgáltasson
egy sztringet és dobjon egy <code>StopIteration</code> kivételt, mikor már elfogyott az adat.
</p>
<p>
NEM kell külön egy függvényt írni, ami fájlból olvassa a sztringeket, egy másikat, amelyik a webről, stb. és aztán ugyanazt csinálják a kapott sztring-sorozattal.
Egyetlen függvény elég, ha a paraméterként kapott objektum megvalósítja az iterátor interfészt. Érdemes végiggondolni, hogy más nyelvekben hogy oldanánk meg
egy ilyen feladatot.
</p>
<h3 id='dunder_functions'>&rtrif; Dunder függvények &ndash; a gépezet elrejtése</h3>
<p>
A double underscore (dunder) metódusokra épp az előbb láttunk példát: ha egy osztály implementálja az <code>__iter__</code> és a <code>__next__</code> metódusokat,
akkor a futtató rendszer ugyanazokkal a módszerekkel (pl.for ciklussal) végig tudja járni az objektum által szolgáltatott elemeket, mint egy számsorozatot. Egy
másik gyakran előforduló szituáció objektumok sztringként való megjelenítése.
</p>
<p>
Készítsünk egy egyszerű kis osztályt és írassuk ki egy példányát sztringként:
<pre>
class MyLittleClass:
    def __init__(self,x):
        self.x = x

m = MyLittleClass(10)
print(m)
<div class='result'>
# <__main__.MyLittleClass object at 0x028A7970>
</div>
</pre>
Ez persze nem túl informatív. Más nyelvekben az a szokásos megoldás, hogy a MyLittleClass-hoz írni kell egy metódust, pl. toString() névvel és ezt fogja majd
meghívni <b>a program</b> ott, ahol szükség van az objektum sztringgé alakítására. A Python viszont más módszert követ: ha definiálunk egy <code>__str__</code>
metódust, akkor ezt <b>a futtató rendszer</b> automatikusan mindenhol felhívja, ahol szükség van sztring formában való megjelenítésre. Ha nincs ilyen metódus,
akkor kiírja az objektum nevét és memóriacímét a fent látható módon. Már az is egy ügyes konvenció, hogy a program ilyenkor nem áll le hibajelzéssel &ndash;
ha az illető objektum nem tud szépen bemutatkozni, akkor csak annyit mond róla: Ez itt egy MyLittleClass fajta objektum, kicsit kuka szegény, de azért
fogadjátok szeretettel.

<pre class='pale'>
class MyLittleClass:
    def __init__(self,x):
        self.x = x

    <span class='nopale'>def __str__(self):
        return f'my little x is: {self.x}'</span>

m = MyLittleClass(10)
print(m)
<div class='result'>
# my little x is: 10
</div>
</pre>
Számos műveletet tehát a Python a háttérben, valahol a gépházban elvégez, ha betartunk bizonyos konvenciókat, ezáltal a programjaink nagyon leegyszerűsödnek.
</p>
<h3 id='data_structures'>&rtrif; Sokféle és rugalmas adatszerkezet</h3>
<p>
A Python alap adatstruktúrái (list, tuple, dict, set...) rugalmasak és egymással kombinálhatóak, ezért a legtöbb esetben függvény bemenő paramétereként is
és visszatérő értékeként is megfelelnek az adott probléma leírására, így aztán nem kell erre a célra külön speciális osztályokat, struktúrákat definiálni.
Ez NAGYON fontos &ndash; nézzük csak át egyszer ilyen szemmel a programjainkat: mekkora része az, ahol az egyik programrész által szolgáltatott adatokat valami
más formára hozunk, hogy a következő programrész fel tudja azokat dolgozni.
</p>
<p>
<u>Érdemes tudatosan tanulmányozni</u> az adatszerkezetek egymásba alakításának módjait. Nagyon jó kis eszköz lesz a szerszámosládánkban! Egy profi nem csak
sok adatszerkezetet ismer, hanem azt is tudja, hogyan lehet egyiket a másikba átvarázsolni.
</p>
<h4 id='misc_type_collections'>&rtrif;&rtrif; Kevert típusok adatszerkezetekben</h4>
<p>
A list, tuple, dict, set adatszerkezetekben keverten fordulhatnak elő különböző típusú adatok:

<pre>
lst = [1300,'John','Bull',180.5]  # int, str, float
tup = (1300,'John','Bull',180.5)
dic = {'id': 1300, 'first_name': 'John', 'family_name': 'Bull', 'height': 180.5}
</pre>
Egy C, C++ vagy Java programozó számára eleinte ez kifejezetten idegesítő tud lenni &ndash; az ember megszokta, hogy a tömbökben egyforma típusú elemek
vannak &ndash; mi ez a rendetlenség, kérem? Aztán hamar kiderül, hogy nagy előny, ha nem kell újabb és újabb összetett típusokat definiálni csak azért, hogy függvények
beszélgetni tudjanak egymással.
</p>
<p>
Az persze igaz, hogy pl. egy tuple-nak nincs egy fix helyen lévő deklarációja, ahol meg tudnánk nézni, milyen mezői vannak, továbbá pozíció szerint kell
elérnünk az elemeket, pl. tudnunk kell, hogy tup[<b>3</b>] írja le a személy magasságát &ndash; de erre a problémára megoldást jelent a standard könyvtár
<code>namedtuple</code> típusa:

<pre>
from collections import namedtuple

Person = namedtuple('Person', 'id first_name family_name height')

john = Person(id = 1300, first_name = 'John', family_name = 'Bull', height = 180.5)
print(john)
print(john<span class='emph_1'>.id</span>, john<span class='emph_1'>[0]</span>)
<div class='result'>
# Person(id=1300, first_name='John', family_name='Bull', height=180.5)
# 1300 1300
</div>
</pre>
Magának a struktúrának és a mezőinek is nevet adtunk; a mezőket névvel is és indexelve is elérhetjük.
</p>
<h4 id='structured_items'>&rtrif;&rtrif; Strukturált elemek adatszerkezetekben</h4>
<p>
A listák, dict-ek, stb. nemcsak elemi adattípusokat tartalmazhatnak, hanem összetetteket is, tehát az adatszerkezeteket egymásba lehet ágyazni.
</p>
<p>
&ofcir; Egy dict-ben az érték lehet például lista vagy tuple:
<pre>
lst = [10, 20]
tup = ('A', 'B')
dic = { 'pi': 3.14, 'e': 2.71 }
d = { 'my_list': lst, 'my_tuple': tup, 'my_dict': dic }
print(d)
<div class='result'>
# {'my_list': [10, 20], 'my_tuple': ('A', 'B'), 'my_dict': {'pi': 3.14, 'e': 2.71}}
</div>
</pre>
&ofcir; Vagy fordítva: egy lista tartalmazhat dict-eket:

<pre>
d_1 = { 'one': 1, 'two': 2 }
d_2 = { 'three': 3, 'four': 2 }
lst = [d_1, d_2]
print(lst)
<div class='result'>
# [ { 'one': 1, 'two': 2 }, { 'three': 3, 'four': 2 } ]
</div>
</pre>
</p>
<h4 id='extended_dict'>&rtrif;&rtrif; Dictionary kulcs bármely fix típus lehet</h4>
<p>
A dict típusnál a kulcs nemcsak sztring vagy szám lehet, hanem bármely fix, változtathatatlan (immutable) típusú elem, például egy tuple is.
Tegyük fel, hogy egy játékprogramban egyes, koordinátáikkal megadott helyeket veszélyesnek, másokat biztonságosnak kell tekintenünk. Ennek
leírására jól jöhet egy ilyen dict:

<pre>
point_1 = (12,20)
point_2 = (30,4)

d = { point_1: 'dangerous', point_2: 'safe' }
print(d)
<div class='result'>
# (12,20): 'dangerous', (30,4): 'safe'
</div>
</pre>
A halmazok is tartalmazhatnak tetszőleges fix típusú objektumokat, ami ezek után nem meglepő, mert a halmazok felfoghatók olyan dict-eknek, amelyekben
csak kulcsok vannak.

<pre>
tup_1 = (10, 20)
tup_2 = (20, 10)
tup_3 = (10, 20)

tup_set = set()
tup_set.add(tup_1)
tup_set.add(tup_2)
tup_set.add(tup_3)

print(tup_set)
<div class='result'>
# {(20,10}, (10,20)}
</div>
</pre>
</p>
<h4 id='data_conversions'>&rtrif;&rtrif; Az adatszerkezetek könnyen átalakíthatók egymásba</h4>
<p>
Nagyon gyakran előfordul, hogy adott ponton az addigi helyett egy más formátumban szeretnénk tárolni az adatainkat.
</p>
<p>
&ofcir; Például egy lista elemeit egy halmazban szeretnénk elhelyezni. Így járunk el:

<pre>
my_lst = [10, 20, 10, 30, 10, 40]
my_set = <span class='emph_1'>set(</span>my_lst<span class='emph_1'>)</span>
print(my_set)
<div class='result'>
# {40, 10, 20, 30}
</div>
</pre>
Hát ez nem túl bonyolult. És nem túl nehezen olvasható.
</p>
<p>
&ofcir; Egy másik példa: a fentebb definiált <code>Person</code> típusú tuple-t át akarjuk alakítani listává vagy dict-té:

<pre>
from collections import namedtuple

Person = namedtuple('Person', 'id first_name family_name height')

john = Person(id = 1300, first_name = 'John', family_name = 'Bull', height = 180.5)

john_lst = <span class='emph_1'>list(</span>john<span class='emph_1'>)</span>
john_dict = john.<span class='emph_1'>_asdict()</span>
print(john_lst)
print(john_dict)
print(john_dict['id'])
<div class='result'>
# [1300, 'John', 'Bull', 180.5]
# OrderedDict([('id', 1300), ('first_name', 'John'), ('family_name', 'Bull'), ('height', 180.5)])
# 1300
</div>
</pre>
Ha ragaszkodunk hozzá, hogy ne <code>OrderedDict</code>, hanem <code>dict</code> struktúrában legyenek John adatai, az sem nehéz:

<pre>
john_dict = <span class='emph_1'>dict(</span>john_dict<span class='emph_1'>)</span>
print(john_dict)
<div class='result'>
# {'id': 1300, 'first_name': 'John', 'family_name': 'Bull', 'height': 180.5}
</div>
</pre>

&ofcir; Egy dict kulcs-érték párjait akarjuk list vagy tuple formába alakítani:

<pre>
d = { 'one': 1, 'two': 2 }
lst = <span class='emph_1'>list(</span>d.items()<span class='emph_1'>)</span>
tup = <span class='emph_1'>tuple(</span>d.items()<span class='emph_1'>)</span>
print(lst)
print(tup)
<div class='result'>
# [('one', 1), ('two', 2)]
# (('one', 1), ('two', 2))
</div>
</pre>

&ofcir; Ugyanez visszafelé: kulcs-érték párokból álló tuple-ok listáját szeretnénk dict formátumra alakítani:

<pre>
lst = [('one', 1), ('two', 2)]
d = <span class='emph_1'>dict(</span>lst<span class='emph_1'>)</span>
print(d)
<div class='result'>
# { 'one': 1, 'two': 2 }
</div>
</pre>
&ofcir; Két listában lévő elemeket így párosítunk össze tuple-ok listájává, hogy ezekből aztán dict-et vagy listát csináljunk:

<pre>
keys   = ['one', 'two']
values = [1, 2]
dic = <span class='emph_1'>dict(</span><span class='emph_2'>zip(keys,values)</span><span class='emph_1'>)</span>
lst = <span class='emph_1'>list(</span><span class='emph_2'>zip(keys,values)</span><span class='emph_1'>)</span>
print(dic)
print(lst)
<div class='result'>
# {'one': 1, 'two': 2}
#[('one', 1), ('two', 2)]
</div>
</pre>
</p>
<h4 id='extendable_types'>Az alap adattípusok bővíthetők</h4>
<p>
Bátrabbak akár le is származtathatnak új típusokat a meglévőkből; mivel a Pythonban MINDEN objektum, az adattípusok is.
<pre>
class MyDict(<span class='emph_1'>dict</span>):
    def __init__(self, args):
        dict.__init__(args)

    def doSomething(self):
        print('Hi! I am a descendant of the famous DICT family!')

md = MyDict({})
md.doSomething()
md['AA'] = 'BB'
print(md['AA'])
<div class='result'>
# Hi! I am a descendant of the famous DICT family!
# BB
</div>
</pre>
Az osztályunk dict-ként is működik és ezen kívül tud még dicsekedni is a felmenőivel.
</p>
<h2 id='introspection'>Introspekció &ndash; objektum az egész világ</h2>
<p>
Programból le tudjuk kérdezni mindenféle modulnak és egyéb objektumnak a tulajdonságait. Ha például arra vagyok kíváncsi, hogy a fentebbi példában szereplő
<code>MyLittleClass</code> osztálynak van-e <b>f1</b> nevű attribútuma vagy metódusa, akkor ezt így tehetem meg:
<pre>
print(<span class='emph_1'>hasattr</span>(MyLittleClass,'f1'))
<div class='result'>
# False
</div>
</pre>

Ha azt szeretném tudni, van-e a <code>MyDict</code> osztálynak doSomething nevű metódusa (tehát végrehajtható attribútuma):

<pre>
has_it = False
if <span class='emph_1'>hasattr</span>(MyDict,'doSomething'):
    attr = <span class='emph_1'>getattr</span>(MyDict,'doSomething')
    if <span class='emph_1'>callable</span>(attr):
        has_it = True

print(has_it)
<div class='result'>
# True
</div>
</pre>

Az introspekciót elsősorban a futtató rendszer használja pl. arra, hogy a "dunder" varázslatokat véghezvigye, de a felhasználói
programokban is néha szükségünk van rá; továbbá a programozónak is hasznos, amikor kíváncsi arra, hogy egy adott modulnak, osztálynak vagy objektumnak milyen
tulajdonságai vannak. Ehhez csak ennyit kell leírni:

<pre>
<span class='emph_1'>dir</span>(MyLittleClass)
</pre>

Mivel a Pythonban MINDEN objektum: a beépített adattípusok, az osztályok, a modulok, a függvények &ndash; ezért mindennek ugyanúgy tudjuk lekérdezni a
tulajdonságait. Ha például az str adattípus nem-dunder tulajdonságait szeretném kilistáztatni:

<pre>
for name in <span class='emph_1'>dir</span>(str):
    if not name.startswith('__'):
        print(name)
<div class='result'>
# capitalize
# casefold
# center
# ...
# title
# translate
# upper
# zfill
</div>
</pre>
Ha ezek után a zfill metódusról akarok további információt:

<pre>
print(<span class='emph_1'>help</span>(str.zfill))
<div class='result'>
# Help on method_descriptor:
#
# zfill(...)
#     S.zfill(width) -> str
#
#     Pad a numeric string S with zeros on the left, to fill a field
#     of the specified width. The string S is never truncated.
</div>
</pre>
</p>
<h3 id='docstrings'>&rtrif; Docstring</h3>
<p>
Az általunk készített modulok, osztályok, függvények tulajdonságai is lekérdezhetővé válnak a help() függvénnyel, ha ellátjuk őket egy úgynevezett
docstring-gel:

<pre>
def myfunc(param):
    '''Returns the input parameter multiplied by 2'''
    return 2 * param

print(<span class='emph_1'>help</span>(myfunc))
<div class='result'>
# Help on function myfunc in module __main__:
#
# myfunc(param)
#     Returns the input parameter multiplied by 2
</div>
</pre>
Mondanom sem kell, hogy ezt is a dunder mechanizmussal valósítja meg a Python: lekérdezi az objektum <code>__doc__</code> attribútumát. Ha nem definiáltunk
docstring-et, akkor a help() függvény a deklarációt adja vissza:

<pre>
def myfunc(param):
    return 2 * param

print(<span class='emph_1'>help</span>(myfunc))
<div class='result'>
# Help on function myfunc in module __main__:
#
# myfunc(param)
</div>
</pre>
tehát itt sem hibajelzéssel reagál az illető tulajdonság hiányára.
</p>
<h2 id='tracing'>Jó hibajelzés</h2>
<p>
Futási hiba esetén nagyon világos formában megkapjuk a teljes stack trace-t, ezáltal a hibakeresés sok esetben nagyon egyszerűvé válik.
</p>
<h2 id='enhanced_indexing'>Indexelés kiterjesztése</h2>
<h3 id='negative_index'>&rtrif; Negatív indexek</h3>
<p>
A tömb-szerű adatszerkezetek elemeit ugyanúgy nulláról kezdődő indexeléssel érjük el, mint más programnyelvekben:

<pre>
lst = [10,20,30,40]

print(lst[0], lst[2], lst[len(lst) - 1])
<div class='result'>
# 10 30 40
</div>
</pre>
viszont lehetőség van elérni az elemeket a sorozat végétől indulva ennél egyszerűbben:

<pre>
print(lst[len(lst) - 1], lst[len(lst) - 2])
<div class='result'>
# 40 30
</div>
</pre>
mégpedig negatív indexekkel, -1-től kezdve:

<pre>
print(lst[-1], lst[-2])
<div class='result'>
# 40 30
</div>
</pre>
</p>
<h3 id='slicing'>&rtrif; Slicing</h3>
<p>
A sorozat egy szeletét, azaz egynél több elemet is meg tudunk címezni:

<pre>
lst = [10,20,30,40,50,60]

print(lst[1:4])
<div class='result'>
# [20, 30, 40]
</div>
</pre>
sőt, lépésközt is definiálni tudunk:

<pre>
print(lst[0::2])
<div class='result'>
# [10, 30, 50]
</div>
</pre>
A meg nem adott paraméternek (itt: a lezáró, utolsó indexnek) a default értékét veszi automatikusan a futtató rendszer. Fordított sorrendben is be tudjuk
járni a sorozatot:

<pre>
print(lst[::-1])
<div class='result'>
# [60, 50, 40, 30, 20, 10]
</div>
</pre>
A slicing numerikus számításokban sűrűn előfordul és nemcsak olvashatóbbá teszi a programjainkat (amikor már megszoktuk ezt a jelölésmódot), hanem a
programrészeket könnyebben kombinálhatóvá is. A numpy modul pedig több dimenziós tömbökre is kiterjeszti a negatív indexeket és a slicing-ot, ezáltal
nagyon tömör, áttekinthető formában tudunk leírni mátrixműveleteket.
</p>
<h2 id='default_params'>Ügyesen választott default paraméterek</h2>
<p>
Számos könyvtári rutinnak sok paramétere van, ezáltal sokféle feladatot meg lehet oldani velük &ndash; viszont ha a tipikusan nem használt paramétereknek
mindig meg kellene adnunk az értékét, akkor használhatatlanul bonyolulttá válna az egész. Elmondható, hogy általában a Python függvényeinél a default paraméterek
ügyesen vannak meghatározva, a gyakori, egyszerűbb eseteket egyszerű függvényhívással tudjuk megoldani.
</p>
<p>
Adott például egy <b>^</b> jelekkel delimitált fájl, melynek első sora tartalmazza az oszlopneveket:

<pre class='data'>
Name^Age^Income
Red^25^1000
Black^50^2000
White^40^1500
Green^30^1200
Yellow^28^1300
Brown^55^2100
Purple^46^3300
^44^2200
NA^44^2200
Mr.NoAge^^6300
Mrs.NoAge^^6400
Dr.NoAge^^7400
trimmer^44^2900
^^
</pre>
Olvassuk ezt be a pandas <code>read_csv</code> függvényének segítségével:

<pre>
import pandas as pd

df = pd.read_csv("input.csv", sep="^")
print(df)
<div class='result'>
#          Name   Age  Income
# 0         Red  25.0  1000.0
# 1       Black  50.0  2000.0
# 2       White  40.0  1500.0
# 3       Green  30.0  1200.0
# 4      Yellow  28.0  1300.0
# 5       Brown  55.0  2100.0
# 6      Purple  46.0  3300.0
# 7         NaN  44.0  2200.0
# 8         NaN  44.0  2200.0
# 9    Mr.NoAge   NaN  6300.0
# 10  Mrs.NoAge   NaN  6400.0
# 11   Dr.NoAge   NaN  7400.0
# 12    trimmer  44.0  2900.0
# 13        NaN   NaN     NaN
</div>
</pre>
A pandas beolvasta az adatokat, megállapította az oszlopok típusát, NaN értéket rendelt az üres cellákhoz és azonosítót adott minden sornak.
</p>
<p>
Ez egy tipikus, legegyszerűbb feladat, a függvényhívás is egyszerű volt. Ami csak azért érdekes, mert a read_csv függvény deklarációja egyébként így néz ki:

<pre>
<span class='emph_1'>pd.read_csv(filepath_or_buffer, sep=','</span>, delimiter=None, header='infer', names=None, index_col=None, usecols=None, squeeze=False,
prefix=None, mangle_dupe_cols=True, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False,
skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False,
infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, iterator=False, chunksize=None, compression='infer',
thousands=None, decimal=b'.', lineterminator=None, quotechar='"', quoting=0, escapechar=None, comment=None, encoding=None, dialect=None,
tupleize_cols=None, error_bad_lines=True, warn_bad_lines=True, skipfooter=0, doublequote=True, delim_whitespace=False, low_memory=True,
memory_map=False, float_precision=None<span class='emph_1'>)</span>
</pre>
és ezek mind nagyon hasznos paraméterek &ndash; de a legegyszerűbb esetben nem is kell tudnunk a létezésükről. Ha a mező-delimiter vessző lenne, akkor még a
<b>sep</b> paramétert sem kellett volna megadnunk. Ha pedig például az első három sort akarjuk beolvasni szemrevételezés céljából, akkor csak az
<b>nrows</b> paramétert kell specifikálnunk:

<pre class='pale'>
import pandas as pd

df = pd.read_csv("input.csv", sep="^"<span class='nopale'>, nrows=3</span>)
print(df)
<div class='result'>
#          Name   Age  Income
# 0         Red  25.0  1000.0
# 1       Black  50.0  2000.0
# 2       White  40.0  1500.0
</div>
</pre>
Szerintem default értékeket ügyesen választani egyáltalán nem triviális feladat. Ha nem alkalmazunk default értékeket, akkor rengeteget kell gépelni, eközben
sok a hibalehetőség és nehezen olvashatóvá válik a program. Ha pedig nem úgy választunk default értékeket, ahogy azt egy átlagos függvény-használó intuitívan
elképzeli, és/vagy ahogy a gyakori esetek diktálják, akkor a program rendszeresen kellemetlen meglepetésekkel fog szolgálni.
</p>
<h2 id='polymorph_params'>Ügyesen választott polimorf paraméterek</h2>
<p>
Egy megjegyzés a <code>read_csv</code> függvény a használatához: fájl útvonal helyett URL-t is megadhatunk, nem kell először letöltenünk a fájlt. Majd ő
megcsinálja. Például:

<pre>
import pandas as pd

df = pd.read_csv("https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/datasets/AirPassengers.csv")
</pre>
Én ezt az esetet, amikor a paraméter típusától függően a függvény mást és mást csinál, polimorf paraméternek hívom &ndash; nem tudom, létezik-e rá
hivatalos megnevezés.
</p>
<p>
Egy másik példa a polimorf paraméterekre a sztringek <code>startswith, endswith</code> metódusa. Ha nem egy sztringet, hanem sztringekből álló
tuple-t adunk meg, akkor mindegyik sztringgel megvizsgálják az egyezést és ha valamelyik illeszkedik a sztring elejére/végére, akkor True értékkel térnek vissza:

<pre>
lst = ['a.txt','b.py','c.html','d.xls']
for e in lst:
    if e.endswith(<span class='emph_1'>'.txt'</span>):
        print(e)
<div class='result'>
# a.txt
</div>
for e in lst:
    if e.endswith(<span class='emph_1'>('.txt','.html')</span>):
        print(e)
<div class='result'>
# a.txt
# c.html
</div>
</pre>
Polimorf paramétereket alkalmazni <b>nagyon</b> ingoványos terület &ndash; ha nem eléggé intuitív a működés, akkor rettenetesen nehezen érthető és
használható interfész lesz az eredmény. A Python nagy érdeme, hogy általában nagyon világosak az ilyen módon megírt függvényei is, kivételeket talán
leginkább a matplotlib-ben lehet találni. De arra van mentség, azokat a funkciókat a MATLAB-ból vették át.
</p>
<h2 id='concise_constructs'>Néhány tömör nyelvi elem</h2>
<p>
A "comprehension" névvel ellátott nyelvi konstrukció (magyar megfelelőjét nem ismerem) nagyon tömör írásmódot tesz lehetővé. Persze ha túlzásba visszük, akkor a
tömörség már inkább rontja az olvashatóságot, semmint javítaná, de megfelelő keretek között tartva nagyon lényegesen megnöveli az áttekinthetőséget.
</p>
<blockquote class="blq_1">
Az, hogy mennyire tömören vagy szószátyár módon tudunk leírni valamit, egyáltalán nem csak esztétikai kérdés. Tömören megfogalmazott állításokkal át tudjuk
tekinteni a probléma és a megoldás lényegét; ha sok segédinformációt is el kell olvasnunk, akkor kevésbé leszünk képesek felfogni a lényeget.
</p>
<p>
El lehet mondani így is, hogyan mozog egy lejtőre tett test:
</p>
<p style='text-align: center; font-size: 120%; color: blue;'>
A nehézségi gyorsulást megszorozzuk a lejtő magasságával és elosztjuk a lejtő hosszával, aztán ezt megszorozzuk az idővel és hozzáadjuk a kezdeti
sebességet.
</p>
<p>
Ez teljesen korrekt. De azért nekem ez jobban tetszik:
</p>
<p style='text-align: center; font-size: 150%;'>
v = g &times; sin &alpha; &times; t + v<sub>0</sub>
</p>
</blockquote>
<p>
Legyen például az a feladat, hogy

<ol>
<li>megnyitunk egy szövegfájlt,</li>
<li>beolvassuk a sorait,</li>
<li>a sorvégjeleket eltávolítjuk,</li>
<li>azon sorokat elhelyezzük egy listában, melyek 3 karakternél hosszabbak és végül</li>
<li>bezárjuk a fájlt.</li>
</ol>
A pythonikus megoldás így néz ki:

<pre>
with open("infile.txt") as f:
    lst = [line.strip() for line in f if len(line.strip()) > 3]
</pre>
(<b>Igen</b>, ebben benne van a fájl bezárása is, bár az nem a comprehension érdeme, hanem a <code>with</code> context manageré, de így legalább vele is találkoztunk.)
</p>
<p>
Persze amíg szokatlan ez a szintaktika, addig nemhogy olvashatónak látjuk, hanem inkább idegesítőnek (én legalábbis így voltam vele) &ndash; de nagyon gyorsan
meg lehet szokni. És bele lehet szeretni.
</p>
<h2 id='function_objects'>Függvényobjektumok, funkcionális programozás</h2>
<p>

Az, hogy a Pythonban a függvények is objektumok &ndash; mint ahogy minden más &ndash; és ezért átadhatók paraméterként más függvényeknek, továbbá lehetnek függvények
visszatérő értékei, hatalmas lehetőségeket rejt magában. Sajnos ezeket kicsi és érthető példákon nem igazán lehet meggyőzően szemléltetni amíg a részletekkel meg nem
ismerkedünk, ezért arra kérem az olvasót, higgye el nekem, hogy funkcionális programozás nagyon hasznos dolog. Azaz húzhatunk még egy vonást a Python
<span class='code_2'>előnyök</span> rubrikájába.
</p>
<p>
És társaságban is nagyon jól veszi ki magát, ha a funkcionális programozást dícsérjük. Kicsi a lebukás veszélye, mert kevesen ismerik, akik meg ismerik, azok
egyet fognak érteni és innen kezdve már csak bólogatnunk kell. Ha valaki mégis rákérdezne, hogy miért is jó az, akkor mérjük végig megvetően az illetőt és távozzunk
gyorsan.
</p>
<h2 id='generators'>Generátorok, korutinok</h2>
<p>
A generátorok olyan különleges függvények, amelyek megőrzik belső állapotukat, újabb és újabb hívásokkal a belsejükbe lehet visszaugrani &ndash; és ez pont
annyira hasznos dolog, mint amennyire érthetetlennek hangzik első hallásra. Ezeket sem lehet jól bemutatni előzetesen, a részletek ismerete nélkül.
</p>
<h2 id='useful_functions'>Sok hasznos függvény és metódus</h2>
<p>
A beépített függvények, a standard könyvtár és az egyéb modulok függvényei rengeteg gyakran előforduló feladatot lefednek, igen sok megoldást készen
kapunk. Nemhogy a kereket nem kell folyton újra feltalálnunk, hanem a traktort és a Ferrarit sem. Nézzünk meg néhány példát.
</p>
<p>
&ofcir; Így iratjuk ki, hogy egy adott elem hányszor szerepel egy listában:

<pre>
lst = [10,20,30,10,50]
print(lst.<span class='emph_1'>count(10)</span>)
<div class='result'>
# 2
</div>
</pre>
&ofcir; Így fordítjuk meg helyben a listát:

<pre>
lst.<span class='emph_1'>reverse()</span>
print(lst)
<div class='result'>
# [50,10,30,20,10]
</div>
</pre>

&ofcir; Így számoljuk meg, hogy egy lista elemei hányszor fordulnak elő:

<pre>
import collections

lst = ['a', 'b', 'c', 'a', 'b', 'b']
c = collections.<span class='emph_1'>Counter</span>(lst)
print(c)
<div class='result'>
Counter({'b': 3, 'a': 2, 'c': 1})
</div>
</pre>

&ofcir; Így iratjuk ki rekurzívan egy könyvtár összes alkönyvtárát:

<pre>
import os
for root, dirs, files in <span class='emph_1'>os.walk</span>("."):
    for name in dirs:
        print(<span class='emph_1'>os.path.join</span>(root, name))
<div class='result'>
# .\Config
# .\DataScience
# .\HDF5
# .\IronPython
# .\Testing
# .\Testing\__pycache__
</div>
</pre>

&ofcir; Így iratjuk ki elemek permutációit:

<pre>
from itertools import permutations

perm = <span class='emph_1'>permutations</span>([1, 2, 3])

print(list(perm))
<div class='result'>
[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
</div>
</pre>
</p>
<h2 id='useful_modules'>Sok hasznos modul jól dokumentálva</h2>
<p>
Nagy a fejlesztő közösség, rengeteg  <a href='https://xkcd.com/353/' target='_blank'>hasznos modul</a> létezik és ezek tipikusan jól le vannak dokumentálva.
Ha képet akarunk kapni arról, hogy hány modul létezik, érdemes <a href='https://pypi.org/' target='_blank'>ide</a> és
<a href='https://pythonawesome.com/' target='_blank'>ide</a> benézni. Vigyázat, mélyvíz!
</p>
<h2 id='easy_install'>Könnyű installálás</h2>
<p>
A modulok installálása szinte kivétel nélkül nagyon egyszerű még akkor is, ha több Python verzió van a gépünkön.
</p>
<h2 id='easy_for_beginners'>Kezdőknek (is) könnyen tanulható</h2>
<p>
A nem nagyon haladó elemei a nyelvnek kifejezetten könnyen elsajátíthatók; nem véletlen, hogy egyre több helyen a Pythont választják bevezető nyelvnek
kezdők (akár gyerekek) számára.
</p>
<h2 id='disadvantages'>...és a hátrányok &#9760;</h2>
<p>
Feltétlenül szólni kell a nyelv hátrányairól is, nehogy az olvasó azt higgye, hogy elfogult vagyok a Python javára.
</p>
<p>
Bár tényleg az vagyok, nincs mit tagadni, ha már így szóbakerült.
</p>
<h3 id='no_typecheck'>&rtrif; Típusellenőrzés hiánya &rArr; futás közben kiderülő hibák</h3>
<p>
Mint minden szkript-nyelvnél, amelynél nincs külön fordítási és típusellenőrzési fázis, egészen komoly hibák is rejtve tudnak maradni, míg az illető program-ágra
nem fut a vezérlés:
<pre>
x = 10
#...
if x < 20:
    print(x)
else:
<div class='big_red'>   xprint(y) <span style='color:black;'># &#128163; (durr)</span></div>
</pre>
Itt az <code>else</code> ágban két hiba is van: nem létezik <b>xprint</b> függvény és nincs definiálva az <b>y</b> változó. Ám ez csak akkor derül ki, amikor
x értéke pl. 100; a fenti esetben problémamentesen lefut a program.
</p>
<p>
<b style='font-size:200%;color:red;'>&#x261e;</b> <span class='emph_1'>TEHÁT: Sokkal</span> gondosabban kell tesztelni, mint a kompilált nyelveknél,
gondoskodni kell róla, hogy minden ágat bejárjunk.
</p>
<p>
Tovább rontja a helyzetet a típusellenőrzés hiánya:

<pre>
lst = [20,30,40]
xst = 10
#...
if xst < 20:
    print(xst)
else:
    <span class='emph_1'>l</span>st = 99 # <span class='emph_1'>x</span>st-t akartunk írni, de nem sikerült

lst.append(200) <span class='big_black'># &#128163; (durr)</span>
</pre>
Ez is csak akkor derül ki, amikor xst pl. 100-as értéket kap. És ilyen hibát nagyon könnyű elkövetni.
</p>
<p>
<b style='font-size:200%;color:red;'>&#x261e;</b> <span class='emph_1'>TEHÁT: Sokkal, de sokkal</span> gondosabban kell tesztelni, mint a típusellenőrzéses
nyelveknél, gondoskodni kell róla, hogy minden ágat bejárjunk.
</p>
<p>
Másik tipikus hiba: kulcsszó-felülírás. Itt például előállítunk egy dict nevű objektumot, ami azt eredményezi, hogy a továbbiakban nem tudjuk ezt a kulcsszót
használni egy dictionary létrehozására. A dict elvesztette kulcsszó jellegét.

<pre>
<span class='emph_1'>dict</span> = { 'A': 1 }
x = 100
#...
if x < 20:
    print(x)
else:
    y = dict()  <span class='big_black'># &#128163; (durr)</span>
</pre>

<b style='font-size:200%;color:red;'>&#x261e;</b> <span class='emph_1'>TEHÁT: Nagyon-nagyon rettentően sokkal, de sokkal</span> gondosabban kell tesztelni, mint a
kompilált nyelveknél, gondoskodni kell róla, hogy minden ágat bejárjunk.
</p>
<p>
Az élesebb szemű olvasók talán sejtik már halványan, hogy az ilyen típusú hibákat és az ellenük való védekezést nagyon fontosnak tartom. És ha maguk is
kergettek már hasonló hibákat nagyobb programokban, akkor biztosan lelkesen bólogatnak. Továbbá nekik is számos ősz hajszáluk van.
</p>
<h3 id='no_declaration'>&rtrif; Deklaráció hiánya &rArr; még futás közben sem kiderülő hibák</h3>
<p>
A változók akkor keletkeznek, amikor először értéket kapnak. Ha egy változónak értéket akarunk adni és elgépeljük a nevét, akkor létrejön egy új változó,
ami esetleg ott árválkodik és senki nem kíváncsi az értékére, miközben a program egészen másképpen viselkedik, mint ahogy kellene neki

<pre>
x = 10
#...
if x < 20:
   print('do something')
   <span class='emph_1'>y</span> = 100   # elgépelés <span class='emph_1'>x</span> = 100 helyett
#...
if x > 20:
   print('do something else') # ide sosem jutunk el
<div class='result'>
# do something
</div>
</pre>
x helyett véletlenül y-t írtunk, ami miatt egy program-ág soha nem hajtódik végre. Ez a legkegyetlenebb hiba: nincs szintaktikai probléma, csak az eredmények
lesznek néha hibásak.
</p>
<p>
<b style='font-size:200%;color:red;'>&#x261e;</b> <span class='emph_1'>TEHÁT: Nagyon-nagyon-<span style='font-size: 90%;'>nagyon-</span><span
style='font-size: 90%;'>nagyon-</span><span style='font-size: 80%;'>nagyon </span> <span style='font-size: 70%;'>de igazán,</span>
<span style='font-size: 50%;'>ne kelljen már mégegyszer elmondanom...</span></span>
</p>
<h3 id='no_private'>&rtrif; Nincsenek private és protected elemek</h3>
<p>
Osztályok definiálásakor nincs arra mód, hogy az adatrejtést <b>kikényszerítsük</b>, azaz hogy egyes attribútumok és metódusok hozzáférhetetlenek legyenek a
külvilág számára. Mi tagadás, ez hátrány, de azért nem nagyon nagy hendikep. Elnevezési konvenciókkal és docstring-ekkel világossá lehet tenni, hogy melyek
a private-nek vagy protected-nek szánt elemek &ndash; és bár a programozók tipikusan önfejű lények, de azért kevesen vannak köztük, akik szándékosan, tiltás
ellenére is rombolják a saját munkájukat. Azaz önhekkerek.
</p>
<h3 id='missing_constructs'>&rtrif; Nincs switch és nincs const</h3>
<p>
Számomra érthetetlen, miért maradt ki a nyelvből a switch (case) utasítás, amely a sokszoros if-else-eket kiváltaná. Időnként nagyon hiányzik. Hasonlóan
hiányolom a konstansokat, amelyeket valamennyire lehet ugyan pótolni egyelemű tuple-lal, de azért nem egészen és ez körülményes is egy kicsit.
</p>
<h3 id='low_speed'>&rtrif; Lassúság?</h3>
<p>
Egy interpretált nyelv, amilyen a Python is, mindig lassúbb egy kompilált nyelvnél, mint amilyen például a C++, hiszen futás közben állítja elő a
bytecode-ból a gépi kódot. A Pythonnál ehhez még hozzájön az, hogy mindent objektumnak tekint, még egy numerikus konstanst is, ezért az értékek elérése
tartalmaz egy járulékos indirekciót.
</p>
<p>
A jó hír viszont az, hogy ez a sebességkülönbség <b>nagyon</b> ritkán zavaró. Akár fájlból olvas a program, akár adatbázisból, akár hálózatról &ndash; ezek
a műveletek sokkal lassúbbak a memória-műveleteknél. A sebesség-különbség csak nagy mennyiségű numerikus számítás esetén válhat zavaróvá, viszont a numerikus
műveletekhez használt modulokat (numpy, Numba) kifejezetten sebességre optimalizáltan alkották meg.
</p>
<p style='text-align:center; font-size: 300%;'>&spades;</p>
</body>
</html>
