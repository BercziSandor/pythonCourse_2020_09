<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=windows-1250" />
<title>Python kóstoló</title>
<style>
  h3   { color: blue; }
  h4   { color: green; }
  body { text-align:justify; margin: 15px 25px 30px 15px; background-color: #F5F5DC; font-family: Arial; font-size: 14; }
  p { margin: 8px 0; }
  pre { color: blue; margin: 8px 8px 8px 20px; }
  code { background-color: black; color: white; padding-left: 3px; padding-right: 3px;  border-radius: 3px; }
  .code_2 { background-color: lightgray; padding-left: 3px; padding-right: 3px;  border-radius: 3px; }
  .pale { color: gray; }
  .nopale { color: blue; }
  .result { color: olivedrab;  margin-top: -10px;  margin-bottom: -10px; }
  .contents { margin-left:30%; color:red; font-size: 120%; }
  .data { color:green; }
  .emph_1 { color: red; font-weight: bold; }
  .emph_2 { color: green; font-weight: bold; }
  .emph_4 { color: gray; font-family: courier new; letter-spacing: 0.1em; }
  .big_red { color:red; font-size:120%; font-weight:bold; margin-top:-5px; margin-bottom:-17px; } /* for div in text */
  .big_black { color:black; font-size:120%; font-weight:bold; margin-top:-5px; margin-bottom:-17px; } /* for div in text */

  .deleted { text-decoration: line-through; color: blue; }
  .question  { font-family:Cooper Black; color:indigo; }
  .sol_button { color:indigo; font-size: 110%; }
  .solution { display:none; border: 1px groove black; border-radius: 5px; margin: 10px 20px 5px 20px; padding: 5px; background-color: palegoldenrod; }
  .emph_box_1 { margin: 20 auto;padding:10px 20px; background-color: #B1BBBA; border: 1px solid black; border-radius: 4px; text-align: center; font-size: 120%; }
  .blq_1  { border-left: 3px solid #FC4;padding-left: 16px; font-family: Georgia; font-style: italic; }
</style>
</head>
<body>
<div style='font-size: 90%; color: blueviolet'>
<span style='float:right;font-style:italic;'>Nemes Mihály &bull; Mihaly.Nemes@t-systems.com</span>
<p style="text-align:center;">&mdash; Utolsó módosítás: 2020.10.01 &mdash;</p>
</div>

<h1 style='text-align:center;'>Python kóstoló</h1>
<p>
<ul class='contents'>
<li><a style='color: red' href='#apologizing'>Egy kis magyarázkodás</a></li>
<li><a style='color: red' href='#easy_combine'>Lego jelleg (elemek könnyû kombinálhatósága)</a>
<ul>
<li><a style='color: red' href='#duck_typing'>Polimorfizmus, dinamikus típusok, duck typing</a>
<ul>
<li><a style='color: red' href='#iterator_interface'>Iterátor interfész példák</a></li>
<li><a style='color: red' href='#testability'>Tesztelhetõség</a></li>
<li><a style='color: red' href='#extended_usability'>Kiterjesztett használhatóság</a></li>
</ul>
</li>
<li><a style='color: red' href='#dunder_functions'>Dunder függvények &ndash; a gépezet elrejtése</a></li>
<li><a style='color: red' href='#data_structures'>Sokféle és rugalmas adatszerkezet</a>
<ul>
<li><a style='color: red' href='#misc_type_collections'>Kevert típusok adatszerkezetekben</a></li>
<li><a style='color: red' href='#structured_items'>Strukturált elemek adatszerkezetekben</a></li>
<li><a style='color: red' href='#extended_dict'>Dictionary kulcs bármely fix típus lehet</a></li>
<li><a style='color: red' href='#data_conversions'>Az adatszerkezetek könnyen átalakíthatók egymásba</a></li>
<li><a style='color: red' href='#extendable_types'>Az alap adattípusok bõvíthetõk</a></li>
</ul>
</li>
</ul>
</li>
<li><a style='color: red' href='#introspection'>Introspekció &ndash; objektum az egész világ</a>
<ul>
<li><a style='color: red' href='#docstrings'>Docstring</a></li>
</ul>
</li>
<li><a style='color: red' href='#tracing'>Jó hibajelzés</a></li>
<li><a style='color: red' href='#enhanced_indexing'>Indexelés kiterjesztése</a>
<ul>
<li><a style='color: red' href='#negative_index'>Negatív indexek</a></li>
<li><a style='color: red' href='#slicing'>Slicing</a></li>
</ul>
</li>
<li><a style='color: red' href='#default_params'>Ügyesen választott default paraméterek</a></li>
<li><a style='color: red' href='#polymorph_params'>Ügyesen választott polimorf paraméterek</a></li>
<li><a style='color: red' href='#concise_constructs'>Néhány tömör nyelvi elem</a></li>
<li><a style='color: red' href='#function_objects'>Függvényobjektumok, funkcionális programozás</a></li>
<li><a style='color: red' href='#generators'>Generátorok, korutinok</a></li>
<li><a style='color: red' href='#useful_functions'>Sok hasznos függvény és metódus</a></li>
<li><a style='color: red' href='#useful_modules'>Sok hasznos modul jól dokumentálva</a></li>
<li><a style='color: red' href='#easy_install'>Könnyû installálás</a></li>
<li><a style='color: red' href='#easy_for_beginners'>Kezdõknek (is) könnyen tanulható</a></li>
<li style='color: black'><a style='color: black' href='#disadvantages'>...és a hátrányok</a> <span style='color: black'>&#9760;</span>
<ul>
<li><a style='color: black' href='#no_typecheck'>Típusellenõrzés hiánya &rarr; futás közben kiderülõ hibák</a></li>
<li><a style='color: black' href='#no_declaration'>Deklaráció hiánya &rarr; még futás közben sem kiderülõ hibák</a></li>
<li><a style='color: black' href='#no_private'>Nincsenek private és protected elemek</a></li>
<li><a style='color: black' href='#missing_constructs'>Nincs switch és nincs const</a></li>
<li><a style='color: black' href='#low_speed'>Lassúság?</a></li>
</ul>
</li>
</ul>
</p>
<h2 id='apologizing'>Egy kis magyarázkodás</h2>
<p>
Noha a Pythonnal való ismerkedés elején járunk, mégis érdemesnek gondolom áttekinteni, hogy mit tartok a nyelv (és a hozzá kapcsolódó ökoszisztéma) elõnyeinek
és hátrányainak, mert hitem szerint így céltudatosabb lehet az ismerkedés, kevésbé fogunk teljesen elveszni a szintaktika tanulmányozásában, jobban és gyorsabban
kirajzolódnak a részleteken túl az egésznek is a körvonalai.
</p>
<p>
Pythonban teljesen kezdõk számára biztosan egyes részek távolinak és elvontnak fognak tûnni &ndash; de szerintem akkor is hasznos egy ilyenfajta bemutatás. Újra
és újra vissza fogunk térni ezekre a gondolatokra és egyre világosabbá fognak válni.
</p>
<p>
Nincs mese, a tanulás már csak ilyen iteratív folyamat.
</p>
<h2 id='easy_combine'>Lego jelleg (elemek könnyû kombinálhatósága)</h2>
<p>
A Python számomra leglenyûgözõbb tulajdonsága az, amilyen könnyen és áttekinthetõen lehet programrészeket, modulokat egymáshoz illeszteni.
</p>
<h3 id='duck_typing'>&rtrif; Polimorfizmus, dinamikus típusok, duck typing</h3>
<p>
A nyelv nagyon fontos tulajdonsága a dinamikus típusosság. Ez azt jelenti, hogy ha egy függvény felhívja a paraméterként kapott objektumnak valamilyen
metódusát, akkor paraméterként minden olyan objektum szerepelhet, amelyik rendelkezik az illetõ metódussal.

<pre>
def func(param):
    param.greeting()

class Early():
    def greeting(self):
        print('Good morning')

class Late():
    def greeting(self):
        print('Good evening')

ea = Early()
la = Late()
func(ea)
func(la)
<div class='result'>
# Good morning
# Good evening
</div>
</pre>
Nincs megkötés arra, hogy a <code>param</code> objektum milyen típusú legyen, csak egy dolog fontos: legyen neki greeting() nevû metódusa. A dinamikus
típusosságnak angolul <span class='code_2'>duck typing</span> a neve, ami arra a mondásra utal, hogy ha valami úgy jár és úgy hápog, mint egy kacsa, akkor
az egy kacsa.
</p>
<p>
A dinamikus típusosság óriási rugalmasságot kölcsönöz a nyelvnek, mintegy szabványos csatlakozókkal látja el az elemeket, amitõl ezek szabadon
kombinálhatóvá válnak.
</p>
<h4 id='iterator_interface'>&rtrif;&rtrif; Iterátor interfész példák</h4>
<p>
Rendkívül gyakran kell valamilyen elemek sorozatának tagjait egyenként elõvennünk. Pythonban így járunk végig
<pre>
<b style='color:black;'>számsorozatot:                 sztringet:               listát vagy tuple-t:        halmazt:</b>
                                                        x = (10,'A',30)
x = range(5)                   x = 'Python'             x = [10,'A',30]             x = {10, 'A', 30}
<span class='emph_1'>for i in x:                    for i in x:              for i in x:                 for i in x:</span>
    print(i,end=' ')               print(i,end=' ')         print(i,end=' ')            print(i,end=' ')
print()                        print()                   print()                    print()
<div class='result'>
# 0 1 2 3 4                    # P y t h o n             # 10 A 30                  # 10 A 30 (a sorrend nem garantált)
</div>
</pre>

<pre>
<b style='color:black;'>szövegfájl sorait:             adatbázistábla sorait:</b>

                               cursor.execute("SELECT * FROM employee")
x = open('demo_1.txt','r')     x = cursor.fetchall()
<span class='emph_1'>for i in x:                    for i in x:</span>
    print(i,end='')                print(i)
<div class='result'>
# line 1                       # (1,'Smith','1990-04-02')
# line 2                       # (2,'Jones','1985-07-11')
</div>
</pre>

Ezek az elemek mind megvalósítják az úgynevezett iterátor interfészt, ezért <b>teljesen egyformán</b> tudjuk megkapni az általuk szolgáltatott adatsorozatot.
Sõt, mi magunk is tudunk írni olyan osztályt, amely megvalósítja ezt az interfészt, ezért az általa szolgáltatott elemeken végig lehet menni egy közönséges for
ciklussal. Példaként vegyünk egy nem túl hasznos, ám annál egyszerûbb osztályt, amely nullától háromig tud számolni:
<pre>
class StupidCounter:
    def __init__(self):
        self.count = 0

    def <span class='emph_1'>__iter__</span>(self):
        return self

    def <span class='emph_1'>__next__</span>(self):
        if self.count > 3:
            raise StopIteration

        ret_val = self.count
        self.count += 1
        return ret_val

c = StupidCounter()
<span class='emph_1'>for i in c:</span>
    print(i,end=' ')
print()
<div class='result'>
# 0 1 2 3
</div>
</pre>
A részletekrõl késõbb majd szó lesz, most csak az a lényeg, hogy ha néhány egyszerû szabályt betartunk, akkor a mi buta kis számlálónkat ugyanúgy tudják
használni a többi programrészek, mint egy listát. Az õ szempontjukból ez egyszerûen csak egy <span class='emph_4'>valami</span>, ami számsorozatot produkál,
ha az <span style='font-family:Comic Sans MS; color:blueviolet;'>iterátor interfész</span> nevû etikett szerint megkérik rá.
</p>
<h4 id='testability'>&rtrif;&rtrif; Tesztelhetõség</h4>
<p>
Többek között a tesztelhetõséget is roppantul javítja a dinamikus típusosság. Ha van például egy függvényünk, amelynek paraméterül egy megnyitott fájl-objektumot
adunk át, hogy abból olvasson sorokat, akkor tesztelhetjük a függvényt akár egy listával is, amelyben sztringek vannak.

<pre>
def func(param):
    for line in param:
        print('I do something with:', line)

f_obj = open('demo_1.txt','r')
func(f_obj)
<div class='result'>
# I do something with: line 1
# I do something with: line 2
</div>

test_data = ['line 1', 'line 2']
func(test_data)
<div class='result'>
# I do something with: line 1
# I do something with: line 2
</div>
</pre>
<h4 id='extended_usability'>&rtrif;&rtrif; Kiterjesztett használhatóság</h4>
<p>
Másrészt nemcsak fájlt, hanem olyan objektumot is átadhatunk paraméterként a függvénynek, amelyik például a webrõl olvas be adatokat. Vagy egy hálózatból.
Vagy kiáshatja akár a zõldséges kertjébõl is, teljesen mindegy, az a lényeg, hogy legyen neki <code>__next__</code> metódusa, aminek hatására szolgáltasson
egy sztringet és dobjon egy <code>StopIteration</code> kivételt, mikor már elfogyott az adat.
</p>
<p>
NEM kell külön egy függvényt írni, ami fájlból olvassa a sztringeket, egy másikat, amelyik a webrõl, stb. és aztán ugyanazt csinálják a kapott sztring-sorozattal.
Egyetlen függvény elég, ha a paraméterként kapott objektum megvalósítja az iterátor interfészt. Érdemes végiggondolni, hogy más nyelvekben hogy oldanánk meg
egy ilyen feladatot.
</p>
<h3 id='dunder_functions'>&rtrif; Dunder függvények &ndash; a gépezet elrejtése</h3>
<p>
A double underscore (dunder) metódusokra épp az elõbb láttunk példát: ha egy osztály implementálja az <code>__iter__</code> és a <code>__next__</code> metódusokat,
akkor a futtató rendszer ugyanazokkal a módszerekkel (pl.for ciklussal) végig tudja járni az objektum által szolgáltatott elemeket, mint egy számsorozatot. Egy
másik gyakran elõforduló szituáció objektumok sztringként való megjelenítése.
</p>
<p>
Készítsünk egy egyszerû kis osztályt és írassuk ki egy példányát sztringként:
<pre>
class MyLittleClass:
    def __init__(self,x):
        self.x = x

m = MyLittleClass(10)
print(m)
<div class='result'>
# <__main__.MyLittleClass object at 0x028A7970>
</div>
</pre>
Ez persze nem túl informatív. Más nyelvekben az a szokásos megoldás, hogy a MyLittleClass-hoz írni kell egy metódust, pl. toString() névvel és ezt fogja majd
meghívni <b>a program</b> ott, ahol szükség van az objektum sztringgé alakítására. A Python viszont más módszert követ: ha definiálunk egy <code>__str__</code>
metódust, akkor ezt <b>a futtató rendszer</b> automatikusan mindenhol felhívja, ahol szükség van sztring formában való megjelenítésre. Ha nincs ilyen metódus,
akkor kiírja az objektum nevét és memóriacímét a fent látható módon. Már az is egy ügyes konvenció, hogy a program ilyenkor nem áll le hibajelzéssel &ndash;
ha az illetõ objektum nem tud szépen bemutatkozni, akkor csak annyit mond róla: Ez itt egy MyLittleClass fajta objektum, kicsit kuka szegény, de azért
fogadjátok szeretettel.

<pre class='pale'>
class MyLittleClass:
    def __init__(self,x):
        self.x = x

    <span class='nopale'>def __str__(self):
        return f'my little x is: {self.x}'</span>

m = MyLittleClass(10)
print(m)
<div class='result'>
# my little x is: 10
</div>
</pre>
Számos mûveletet tehát a Python a háttérben, valahol a gépházban elvégez, ha betartunk bizonyos konvenciókat, ezáltal a programjaink nagyon leegyszerûsödnek.
</p>
<h3 id='data_structures'>&rtrif; Sokféle és rugalmas adatszerkezet</h3>
<p>
A Python alap adatstruktúrái (list, tuple, dict, set...) rugalmasak és egymással kombinálhatóak, ezért a legtöbb esetben függvény bemenõ paramétereként is
és visszatérõ értékeként is megfelelnek az adott probléma leírására, így aztán nem kell erre a célra külön speciális osztályokat, struktúrákat definiálni.
Ez NAGYON fontos &ndash; nézzük csak át egyszer ilyen szemmel a programjainkat: mekkora része az, ahol az egyik programrész által szolgáltatott adatokat valami
más formára hozunk, hogy a következõ programrész fel tudja azokat dolgozni.
</p>
<p>
<u>Érdemes tudatosan tanulmányozni</u> az adatszerkezetek egymásba alakításának módjait. Nagyon jó kis eszköz lesz a szerszámosládánkban! Egy profi nem csak
sok adatszerkezetet ismer, hanem azt is tudja, hogyan lehet egyiket a másikba átvarázsolni.
</p>
<h4 id='misc_type_collections'>&rtrif;&rtrif; Kevert típusok adatszerkezetekben</h4>
<p>
A list, tuple, dict, set adatszerkezetekben keverten fordulhatnak elõ különbözõ típusú adatok:

<pre>
lst = [1300,'John','Bull',180.5]  # int, str, float
tup = (1300,'John','Bull',180.5)
dic = {'id': 1300, 'first_name': 'John', 'family_name': 'Bull', 'height': 180.5}
</pre>
Egy C, C++ vagy Java programozó számára eleinte ez kifejezetten idegesítõ tud lenni &ndash; az ember megszokta, hogy a tömbökben egyforma típusú elemek
vannak &ndash; mi ez a rendetlenség, kérem? Aztán hamar kiderül, hogy nagy elõny, ha nem kell újabb és újabb összetett típusokat definiálni csak azért, hogy függvények
beszélgetni tudjanak egymással.
</p>
<p>
Az persze igaz, hogy pl. egy tuple-nak nincs egy fix helyen lévõ deklarációja, ahol meg tudnánk nézni, milyen mezõi vannak, továbbá pozíció szerint kell
elérnünk az elemeket, pl. tudnunk kell, hogy tup[<b>3</b>] írja le a személy magasságát &ndash; de erre a problémára megoldást jelent a standard könyvtár
<code>namedtuple</code> típusa:

<pre>
from collections import namedtuple

Person = namedtuple('Person', 'id first_name family_name height')

john = Person(id = 1300, first_name = 'John', family_name = 'Bull', height = 180.5)
print(john)
print(john<span class='emph_1'>.id</span>, john<span class='emph_1'>[0]</span>)
<div class='result'>
# Person(id=1300, first_name='John', family_name='Bull', height=180.5)
# 1300 1300
</div>
</pre>
Magának a struktúrának és a mezõinek is nevet adtunk; a mezõket névvel is és indexelve is elérhetjük.
</p>
<h4 id='structured_items'>&rtrif;&rtrif; Strukturált elemek adatszerkezetekben</h4>
<p>
A listák, dict-ek, stb. nemcsak elemi adattípusokat tartalmazhatnak, hanem összetetteket is, tehát az adatszerkezeteket egymásba lehet ágyazni.
</p>
<p>
&ofcir; Egy dict-ben az érték lehet például lista vagy tuple:
<pre>
lst = [10, 20]
tup = ('A', 'B')
dic = { 'pi': 3.14, 'e': 2.71 }
d = { 'my_list': lst, 'my_tuple': tup, 'my_dict': dic }
print(d)
<div class='result'>
# {'my_list': [10, 20], 'my_tuple': ('A', 'B'), 'my_dict': {'pi': 3.14, 'e': 2.71}}
</div>
</pre>
&ofcir; Vagy fordítva: egy lista tartalmazhat dict-eket:

<pre>
d_1 = { 'one': 1, 'two': 2 }
d_2 = { 'three': 3, 'four': 2 }
lst = [d_1, d_2]
print(lst)
<div class='result'>
# [ { 'one': 1, 'two': 2 }, { 'three': 3, 'four': 2 } ]
</div>
</pre>
</p>
<h4 id='extended_dict'>&rtrif;&rtrif; Dictionary kulcs bármely fix típus lehet</h4>
<p>
A dict típusnál a kulcs nemcsak sztring vagy szám lehet, hanem bármely fix, változtathatatlan (immutable) típusú elem, például egy tuple is.
Tegyük fel, hogy egy játékprogramban egyes, koordinátáikkal megadott helyeket veszélyesnek, másokat biztonságosnak kell tekintenünk. Ennek
leírására jól jöhet egy ilyen dict:

<pre>
point_1 = (12,20)
point_2 = (30,4)

d = { point_1: 'dangerous', point_2: 'safe' }
print(d)
<div class='result'>
# (12,20): 'dangerous', (30,4): 'safe'
</div>
</pre>
A halmazok is tartalmazhatnak tetszõleges fix típusú objektumokat, ami ezek után nem meglepõ, mert a halmazok felfoghatók olyan dict-eknek, amelyekben
csak kulcsok vannak.

<pre>
tup_1 = (10, 20)
tup_2 = (20, 10)
tup_3 = (10, 20)

tup_set = set()
tup_set.add(tup_1)
tup_set.add(tup_2)
tup_set.add(tup_3)

print(tup_set)
<div class='result'>
# {(20,10}, (10,20)}
</div>
</pre>
</p>
<h4 id='data_conversions'>&rtrif;&rtrif; Az adatszerkezetek könnyen átalakíthatók egymásba</h4>
<p>
Nagyon gyakran elõfordul, hogy adott ponton az addigi helyett egy más formátumban szeretnénk tárolni az adatainkat.
</p>
<p>
&ofcir; Például egy lista elemeit egy halmazban szeretnénk elhelyezni. Így járunk el:

<pre>
my_lst = [10, 20, 10, 30, 10, 40]
my_set = <span class='emph_1'>set(</span>my_lst<span class='emph_1'>)</span>
print(my_set)
<div class='result'>
# {40, 10, 20, 30}
</div>
</pre>
Hát ez nem túl bonyolult. És nem túl nehezen olvasható.
</p>
<p>
&ofcir; Egy másik példa: a fentebb definiált <code>Person</code> típusú tuple-t át akarjuk alakítani listává vagy dict-té:

<pre>
from collections import namedtuple

Person = namedtuple('Person', 'id first_name family_name height')

john = Person(id = 1300, first_name = 'John', family_name = 'Bull', height = 180.5)

john_lst = <span class='emph_1'>list(</span>john<span class='emph_1'>)</span>
john_dict = john.<span class='emph_1'>_asdict()</span>
print(john_lst)
print(john_dict)
print(john_dict['id'])
<div class='result'>
# [1300, 'John', 'Bull', 180.5]
# OrderedDict([('id', 1300), ('first_name', 'John'), ('family_name', 'Bull'), ('height', 180.5)])
# 1300
</div>
</pre>
Ha ragaszkodunk hozzá, hogy ne <code>OrderedDict</code>, hanem <code>dict</code> struktúrában legyenek John adatai, az sem nehéz:

<pre>
john_dict = <span class='emph_1'>dict(</span>john_dict<span class='emph_1'>)</span>
print(john_dict)
<div class='result'>
# {'id': 1300, 'first_name': 'John', 'family_name': 'Bull', 'height': 180.5}
</div>
</pre>

&ofcir; Egy dict kulcs-érték párjait akarjuk list vagy tuple formába alakítani:

<pre>
d = { 'one': 1, 'two': 2 }
lst = <span class='emph_1'>list(</span>d.items()<span class='emph_1'>)</span>
tup = <span class='emph_1'>tuple(</span>d.items()<span class='emph_1'>)</span>
print(lst)
print(tup)
<div class='result'>
# [('one', 1), ('two', 2)]
# (('one', 1), ('two', 2))
</div>
</pre>

&ofcir; Ugyanez visszafelé: kulcs-érték párokból álló tuple-ok listáját szeretnénk dict formátumra alakítani:

<pre>
lst = [('one', 1), ('two', 2)]
d = <span class='emph_1'>dict(</span>lst<span class='emph_1'>)</span>
print(d)
<div class='result'>
# { 'one': 1, 'two': 2 }
</div>
</pre>
&ofcir; Két listában lévõ elemeket így párosítunk össze tuple-ok listájává, hogy ezekbõl aztán dict-et vagy listát csináljunk:

<pre>
keys   = ['one', 'two']
values = [1, 2]
dic = <span class='emph_1'>dict(zip(</span>keys,values<span class='emph_1'>))</span>
lst = <span class='emph_1'>list(zip(</span>keys,values<span class='emph_1'>))</span>
print(dic)
print(lst)
<div class='result'>
# {'one': 1, 'two': 2}
#[('one', 1), ('two', 2)]
</div>
</pre>
</p>
<h4 id='extendable_types'>Az alap adattípusok bõvíthetõk</h4>
<p>
Bátrabbak akár le is származtathatnak új típusokat a meglévõkbõl; mivel a Pythonban MINDEN objektum, az adattípusok is.
<pre>
class MyDict(<span class='emph_1'>dict</span>):
    def __init__(self, args):
        dict.__init__(args)

    def doSomething(self):
        print('Hi! I am a descendant of the famous DICT family!')

md = MyDict({})
md.doSomething()
md['AA'] = 'BB'
print(md['AA'])
<div class='result'>
# Hi! I am a descendant of the famous DICT family!
# BB
</div>
</pre>
Az osztályunk dict-ként is mûködik és ezen kívül tud még dicsekedni is a felmenõivel.
</p>
<h2 id='introspection'>Introspekció &ndash; objektum az egész világ</h2>
<p>
Programból le tudjuk kérdezni mindenféle modulnak és egyéb objektumnak a tulajdonságait. Ha például arra vagyok kíváncsi, hogy a fentebbi példában szereplõ
<code>MyLittleClass</code> osztálynak van-e <b>f1</b> nevû attribútuma vagy metódusa, akkor ezt így tehetem meg:
<pre>
print(<span class='emph_1'>hasattr</span>(MyLittleClass,'f1'))
<div class='result'>
# False
</div>
</pre>

Ha azt szeretném tudni, van-e a <code>MyDict</code> osztálynak doSomething nevû metódusa (tehát végrehajtható attribútuma):

<pre>
has_it = False
if <span class='emph_1'>hasattr</span>(MyDict,'doSomething'):
    attr = <span class='emph_1'>getattr</span>(MyDict,'doSomething')
    if <span class='emph_1'>callable</span>(attr):
        has_it = True

print(has_it)
<div class='result'>
# True
</div>
</pre>

Az introspekciót elsõsorban a futtató rendszer használja pl. arra, hogy a "dunder" varázslatokat véghezvigye, de a felhasználói
programokban is néha szükségünk van rá; továbbá a programozónak is hasznos, amikor kíváncsi arra, hogy egy adott modulnak, osztálynak vagy objektumnak milyen
tulajdonságai vannak. Ehhez csak ennyit kell leírni:

<pre>
<span class='emph_1'>dir</span>(MyLittleClass)
</pre>

Mivel a Pythonban MINDEN objektum: a beépített adattípusok, az osztályok, a modulok, a függvények &ndash; ezért mindennek ugyanúgy tudjuk lekérdezni a
tulajdonságait. Ha például az str adattípus nem-dunder tulajdonságait szeretném kilistáztatni:

<pre>
for name in <span class='emph_1'>dir</span>(str):
    if not name.startswith('__'):
        print(name)
<div class='result'>
# capitalize
# casefold
# center
# ...
# title
# translate
# upper
# zfill
</div>
</pre>
Ha ezek után a zfill metódusról akarok további információt:

<pre>
print(<span class='emph_1'>help</span>(str.zfill))
<div class='result'>
# Help on method_descriptor:
#
# zfill(...)
#     S.zfill(width) -> str
#
#     Pad a numeric string S with zeros on the left, to fill a field
#     of the specified width. The string S is never truncated.
</div>
</pre>
</p>
<h3 id='docstrings'>&rtrif; Docstring</h3>
<p>
Az általunk készített modulok, osztályok, függvények tulajdonságai is lekérdezhetõvé válnak a help() függvénnyel, ha ellátjuk õket egy úgynevezett
docstring-gel:

<pre>
def myfunc(param):
    '''Returns the input parameter multiplied by 2'''
    return 2 * param

print(<span class='emph_1'>help</span>(myfunc))
<div class='result'>
# Help on function myfunc in module __main__:
#
# myfunc(param)
#     Returns the input parameter multiplied by 2
</div>
</pre>
Mondanom sem kell, hogy ezt is a dunder mechanizmussal valósítja meg a Python: lekérdezi az objektum <code>__doc__</code> attribútumát. Ha nem definiáltunk
docstring-et, akkor a help() függvény a deklarációt adja vissza:

<pre>
def myfunc(param):
    return 2 * param

print(<span class='emph_1'>help</span>(myfunc))
<div class='result'>
# Help on function myfunc in module __main__:
#
# myfunc(param)
</div>
</pre>
tehát itt sem hibajelzéssel reagál az illetõ tulajdonság hiányára.
</p>
<h2 id='tracing'>Jó hibajelzés</h2>
<p>
Futási hiba esetén nagyon világos formában megkapjuk a teljes stack trace-t, ezáltal a hibakeresés sok esetben nagyon egyszerûvé válik.
</p>
<h2 id='enhanced_indexing'>Indexelés kiterjesztése</h2>
<h3 id='negative_index'>&rtrif; Negatív indexek</h3>
<p>
A tömb-szerû adatszerkezetek elemeit ugyanúgy nulláról kezdõdõ indexeléssel érjük el, mint más programnyelvekben:

<pre>
lst = [10,20,30,40]

print(lst[0], lst[2], lst[len(lst) - 1])
<div class='result'>
# 10 30 40
</div>
</pre>
viszont lehetõség van elérni az elemeket a sorozat végétõl indulva ennél egyszerûbben:

<pre>
print(lst[len(lst) - 1], lst[len(lst) - 2])
<div class='result'>
# 40 30
</div>
</pre>
mégpedig negatív indexekkel, -1-tõl kezdve:

<pre>
print(lst[-1], lst[-2])
<div class='result'>
# 40 30
</div>
</pre>
</p>
<h3 id='slicing'>&rtrif; Slicing</h3>
<p>
A sorozat egy szeletét, azaz egynél több elemet is meg tudunk címezni:

<pre>
lst = [10,20,30,40,50,60]

print(lst[1:4])
<div class='result'>
# [20, 30, 40]
</div>
</pre>
sõt, lépésközt is definiálni tudunk:

<pre>
print(lst[0::2])
<div class='result'>
# [10, 30, 50]
</div>
</pre>
A meg nem adott paraméternek (itt: a lezáró, utolsó indexnek) a default értékét veszi automatikusan a futtató rendszer. Fordított sorrendben is be tudjuk
járni a sorozatot:

<pre>
print(lst[::-1])
<div class='result'>
# [60, 50, 40, 30, 20, 10]
</div>
</pre>
A slicing numerikus számításokban sûrûn elõfordul és nemcsak olvashatóbbá teszi a programjainkat (amikor már megszoktuk ezt a jelölésmódot), hanem a
programrészeket könnyebben kombinálhatóvá is. A numpy modul pedig több dimenziós tömbökre is kiterjeszti a negatív indexeket és a slicing-ot, ezáltal
nagyon tömör, áttekinthetõ formában tudunk leírni mátrixmûveleteket.
</p>
<h2 id='default_params'>Ügyesen választott default paraméterek</h2>
<p>
Számos könyvtári rutinnak sok paramétere van, ezáltal sokféle feladatot meg lehet oldani velük &ndash; viszont ha a tipikusan nem használt paramétereknek
mindig meg kellene adnunk az értékét, akkor használhatatlanul bonyolulttá válna az egész. Elmondható, hogy általában a Python függvényeinél a default paraméterek
ügyesen vannak meghatározva, a gyakori, egyszerûbb eseteket egyszerû függvényhívással tudjuk megoldani.
</p>
<p>
Adott például egy <b>^</b> jelekkel delimitált fájl, melynek elsõ sora tartalmazza az oszlopneveket:

<pre class='data'>
Name^Age^Income
Red^25^1000
Black^50^2000
White^40^1500
Green^30^1200
Yellow^28^1300
Brown^55^2100
Purple^46^3300
^44^2200
NA^44^2200
Mr.NoAge^^6300
Mrs.NoAge^^6400
Dr.NoAge^^7400
trimmer^44^2900
^^
</pre>
Olvassuk ezt be a pandas <code>read_csv</code> függvényének segítségével:

<pre>
import pandas as pd

df = pd.read_csv("input.csv", sep="^")
print(df)
<div class='result'>
#          Name   Age  Income
# 0         Red  25.0  1000.0
# 1       Black  50.0  2000.0
# 2       White  40.0  1500.0
# 3       Green  30.0  1200.0
# 4      Yellow  28.0  1300.0
# 5       Brown  55.0  2100.0
# 6      Purple  46.0  3300.0
# 7         NaN  44.0  2200.0
# 8         NaN  44.0  2200.0
# 9    Mr.NoAge   NaN  6300.0
# 10  Mrs.NoAge   NaN  6400.0
# 11   Dr.NoAge   NaN  7400.0
# 12    trimmer  44.0  2900.0
# 13        NaN   NaN     NaN
</div>
</pre>
A pandas beolvasta az adatokat, megállapította az oszlopok típusát, NaN értéket rendelt az üres cellákhoz és azonosítót adott minden sornak.
</p>
<p>
Ez egy tipikus, legegyszerûbb feladat, a függvényhívás is egyszerû volt. Ami csak azért érdekes, mert a read_csv függvény deklarációja egyébként így néz ki:

<pre>
<span class='emph_1'>pd.read_csv(filepath_or_buffer, sep=','</span>, delimiter=None, header='infer', names=None, index_col=None, usecols=None, squeeze=False,
prefix=None, mangle_dupe_cols=True, dtype=None, engine=None, converters=None, true_values=None, false_values=None, skipinitialspace=False,
skiprows=None, nrows=None, na_values=None, keep_default_na=True, na_filter=True, verbose=False, skip_blank_lines=True, parse_dates=False,
infer_datetime_format=False, keep_date_col=False, date_parser=None, dayfirst=False, iterator=False, chunksize=None, compression='infer',
thousands=None, decimal=b'.', lineterminator=None, quotechar='"', quoting=0, escapechar=None, comment=None, encoding=None, dialect=None,
tupleize_cols=None, error_bad_lines=True, warn_bad_lines=True, skipfooter=0, doublequote=True, delim_whitespace=False, low_memory=True,
memory_map=False, float_precision=None<span class='emph_1'>)</span>
</pre>
és ezek mind nagyon hasznos paraméterek &ndash; de a legegyszerûbb esetben nem is kell tudnunk a létezésükrõl. Ha a mezõ-delimiter vesszõ lenne, akkor még a
<b>sep</b> paramétert sem kellett volna megadnunk. Ha pedig például az elsõ három sort akarjuk beolvasni szemrevételezés céljából, akkor csak az
<b>nrows</b> paramétert kell specifikálnunk:

<pre class='pale'>
import pandas as pd

df = pd.read_csv("input.csv", sep="^"<span class='nopale'>, nrows=3</span>)
print(df)
<div class='result'>
#          Name   Age  Income
# 0         Red  25.0  1000.0
# 1       Black  50.0  2000.0
# 2       White  40.0  1500.0
</div>
</pre>
Szerintem default értékeket ügyesen választani egyáltalán nem triviális feladat. Ha nem alkalmazunk default értékeket, akkor rengeteget kell gépelni, eközben
sok a hibalehetõség és nehezen olvashatóvá válik a program. Ha pedig nem úgy választunk default értékeket, ahogy azt egy átlagos függvény-használó intuitívan
elképzeli, és/vagy ahogy a gyakori esetek diktálják, akkor a program rendszeresen kellemetlen meglepetésekkel fog szolgálni.
</p>
<h2 id='polymorph_params'>Ügyesen választott polimorf paraméterek</h2>
<p>
Egy megjegyzés a <code>read_csv</code> függvény a használatához: fájl útvonal helyett URL-t is megadhatunk, nem kell elõször letöltenünk a fájlt. Majd õ
megcsinálja. Például:

<pre>
import pandas as pd

df = pd.read_csv("https://raw.github.com/vincentarelbundock/Rdatasets/master/csv/datasets/AirPassengers.csv")
</pre>
Én ezt az esetet, amikor a paraméter típusától függõen a függvény mást és mást csinál, polimorf paraméternek hívom &ndash; nem tudom, létezik-e rá
hivatalos megnevezés.
</p>
<p>
Egy másik példa a polimorf paraméterekre a sztringek <code>startswith, endswith</code> metódusa. Ha nem egy sztringet, hanem sztringekbõl álló
tuple-t adunk meg, akkor mindegyik sztringgel megvizsgálják az egyezést és ha valamelyik illeszkedik a sztring elejére/végére, akkor True értékkel térnek vissza:

<pre>
lst = ['a.txt','b.py','c.html','d.xls']
for e in lst:
    if e.endswith(<span class='emph_1'>'.txt'</span>):
        print(e)
<div class='result'>
# a.txt
</div>
for e in lst:
    if e.endswith(<span class='emph_1'>('.txt','.html')</span>):
        print(e)
<div class='result'>
# a.txt
# c.html
</div>
</pre>
Polimorf paramétereket alkalmazni <b>nagyon</b> ingoványos terület &ndash; ha nem eléggé intuitív a mûködés, akkor rettenetesen nehezen érthetõ és
használható interfész lesz az eredmény. A Python nagy érdeme, hogy általában nagyon világosak az ilyen módon megírt függvényei is, kivételeket talán
leginkább a matplotlib-ben lehet találni. De arra van mentség, azokat a funkciókat a MATLAB-ból vették át.
</p>
<h2 id='concise_constructs'>Néhány tömör nyelvi elem</h2>
<p>
A "comprehension" névvel ellátott nyelvi konstrukció (magyar megfelelõjét nem ismerem) nagyon tömör írásmódot tesz lehetõvé. Persze ha túlzásba visszük, akkor a
tömörség már inkább rontja az olvashatóságot, semmint javítaná, de megfelelõ keretek között tartva nagyon lényegesen megnöveli az áttekinthetõséget.
</p>
<blockquote class="blq_1">
Az, hogy mennyire tömören vagy szószátyár módon tudunk leírni valamit, egyáltalán nem csak esztétikai kérdés. Tömören megfogalmazott állításokkal át tudjuk
tekinteni a probléma és a megoldás lényegét; ha sok segédinformációt is el kell olvasnunk, akkor kevésbé leszünk képesek felfogni a lényeget.
</p>
<p>
El lehet mondani így is, hogyan mozog egy lejtõre tett test:
</p>
<p style='text-align: center; font-size: 120%; color: blue;'>
A nehézségi gyorsulást megszorozzuk a lejtõ magasságával és elosztjuk a lejtõ hosszával, aztán ezt megszorozzuk az idõvel és hozzáadjuk a kezdeti
sebességet.
</p>
<p>
Ez teljesen korrekt. De azért nekem ez jobban tetszik:
</p>
<p style='text-align: center; font-size: 150%;'>
v = g &times; sin &alpha; &times; t + v<sub>0</sub>
</p>
</blockquote>
<p>
Legyen például az a feladat, hogy

<ol>
<li>megnyitunk egy szövegfájlt,</li>
<li>beolvassuk a sorait,</li>
<li>a sorvégjeleket eltávolítjuk,</li>
<li>azon sorokat elhelyezzük egy listában, melyek 3 karakternél hosszabbak és végül</li>
<li>bezárjuk a fájlt.</li>
</ol>
A pythonikus megoldás így néz ki:

<pre>
with open("infile.txt") as f:
    lst = [line.strip() for line in f if len(line.strip()) > 3]
</pre>
(<b>Igen</b>, ebben benne van a fájl bezárása is, bár az nem a comprehension érdeme, hanem a <code>with</code> context manageré, de így legalább vele is találkoztunk.)
</p>
<p>
Persze amíg szokatlan ez a szintaktika, addig nemhogy olvashatónak látjuk, hanem inkább idegesítõnek (én legalábbis így voltam vele) &ndash; de nagyon gyorsan
meg lehet szokni. És bele lehet szeretni.
</p>
<h2 id='function_objects'>Függvényobjektumok, funkcionális programozás</h2>
<p>

Az, hogy a Pythonban a függvények is objektumok &ndash; mint ahogy minden más &ndash; és ezért átadhatók paraméterként más függvényeknek, továbbá lehetnek függvények
visszatérõ értékei, hatalmas lehetõségeket rejt magában. Sajnos ezeket kicsi és érthetõ példákon nem igazán lehet meggyõzõen szemléltetni amíg a részletekkel meg nem
ismerkedünk, ezért arra kérem az olvasót, higgye el nekem, hogy funkcionális programozás nagyon hasznos dolog. Azaz húzhatunk még egy vonást a Python
<span class='code_2'>elõnyök</span> rubrikájába.
</p>
<p>
És társaságban is nagyon jól veszi ki magát, ha a funkcionális programozást dícsérjük. Kicsi a lebukás veszélye, mert kevesen ismerik, akik meg ismerik, azok
egyet fognak érteni és innen kezdve már csak bólogatnunk kell. Ha valaki mégis rákérdezne, hogy miért is jó az, akkor mérjük végig megvetõen az illetõt és távozzunk
gyorsan.
</p>
<h2 id='generators'>Generátorok, korutinok</h2>
<p>
A generátorok olyan különleges függvények, amelyek megõrzik belsõ állapotukat, újabb és újabb hívásokkal a belsejükbe lehet visszaugrani &ndash; és ez pont
annyira hasznos dolog, mint amennyire érthetetlennek hangzik elsõ hallásra. Ezeket sem lehet jól bemutatni elõzetesen, a részletek ismerete nélkül.
</p>
<h2 id='useful_functions'>Sok hasznos függvény és metódus</h2>
<p>
A beépített függvények, a standard könyvtár és az egyéb modulok függvényei rengeteg gyakran elõforduló feladatot lefednek, igen sok megoldást készen
kapunk. Nemhogy a kereket nem kell folyton újra feltalálnunk, hanem a traktort és a Ferrarit sem. Nézzünk meg néhány példát.
</p>
<p>
&ofcir; Így iratjuk ki, hogy egy adott elem hányszor szerepel egy listában:

<pre>
lst = [10,20,30,10,50]
print(lst.<span class='emph_1'>count(10)</span>)
<div class='result'>
# 2
</div>
</pre>
&ofcir; Így fordítjuk meg helyben a listát:

<pre>
lst.<span class='emph_1'>reverse()</span>
print(lst)
<div class='result'>
# [50,10,30,20,10]
</div>
</pre>

&ofcir; Így számoljuk meg, hogy egy lista elemei hányszor fordulnak elõ:

<pre>
import collections

lst = ['a', 'b', 'c', 'a', 'b', 'b']
c = collections.<span class='emph_1'>Counter</span>(lst)
print(c)
<div class='result'>
Counter({'b': 3, 'a': 2, 'c': 1})
</div>
</pre>

&ofcir; Így iratjuk ki rekurzívan egy könyvtár összes alkönyvtárát:

<pre>
import os
for root, dirs, files in <span class='emph_1'>os.walk</span>("."):
    for name in dirs:
        print(<span class='emph_1'>os.path.join</span>(root, name))
<div class='result'>
# .\Config
# .\DataScience
# .\HDF5
# .\IronPython
# .\Testing
# .\Testing\__pycache__
</div>
</pre>

&ofcir; Így iratjuk ki elemek permutációit:

<pre>
from itertools import permutations

perm = <span class='emph_1'>permutations</span>([1, 2, 3])

print(list(perm))
<div class='result'>
[(1, 2, 3), (1, 3, 2), (2, 1, 3), (2, 3, 1), (3, 1, 2), (3, 2, 1)]
</div>
</pre>
</p>
<h2 id='useful_modules'>Sok hasznos modul jól dokumentálva</h2>
<p>
Nagy a fejlesztõ közösség, rengeteg  <a href='https://xkcd.com/353/' target='_blank'>hasznos modul</a> létezik és ezek tipikusan jól le vannak dokumentálva.
Ha képet akarunk kapni arról, hogy hány modul létezik, érdemes <a href='https://pythonawesome.com/' target='_blank'>ide</a> benézni. Vigyázat, mélyvíz!
</p>
<h2 id='easy_install'>Könnyû installálás</h2>
<p>
A modulok installálása szinte kivétel nélkül nagyon egyszerû még akkor is, ha több Python verzió van a gépünkön.
</p>
<h2 id='easy_for_beginners'>Kezdõknek (is) könnyen tanulható</h2>
<p>
A nem nagyon haladó elemei a nyelvnek kifejezetten könnyen elsajátíthatók; nem véletlen, hogy egyre több helyen a Pythont választják bevezetõ nyelvnek
kezdõk (akár gyerekek) számára.
</p>
<h2 id='disadvantages'>...és a hátrányok &#9760;</h2>
<p>
Feltétlenül szólni kell a nyelv hátrányairól is, nehogy az olvasó azt higgye, hogy elfogult vagyok a Python javára.
</p>
<p>
Bár tényleg az vagyok, nincs mit tagadni, ha már így szóbakerült.
</p>
<h3 id='no_typecheck'>&rtrif; Típusellenõrzés hiánya &rArr; futás közben kiderülõ hibák</h3>
<p>
Mint minden szkript-nyelvnél, amelynél nincs külön fordítási és típusellenõrzési fázis, egészen komoly hibák is rejtve tudnak maradni, míg az illetõ program-ágra
nem fut a vezérlés:
<pre>
x = 10
#...
if x < 20:
    print(x)
else:
<div class='big_red'>   xprint(y) <span style='color:black;'># &#128163; (durr)</span></div>
</pre>
Itt az <code>else</code> ágban két hiba is van: nem létezik <b>xprint</b> függvény és nincs definiálva az <b>y</b> változó. Ám ez csak akkor derül ki, amikor
x értéke pl. 100; a fenti esetben problémamentesen lefut a program.
</p>
<p>
<b style='font-size:200%;color:red;'>&#x261e;</b> <span class='emph_1'>TEHÁT: Sokkal</span> gondosabban kell tesztelni, mint a kompilált nyelveknél,
gondoskodni kell róla, hogy minden ágat bejárjunk.
</p>
<p>
Tovább rontja a helyzetet a típusellenõrzés hiánya:

<pre>
lst = [20,30,40]
xst = 10
#...
if xst < 20:
    print(xst)
else:
    <span class='emph_1'>l</span>st = 99 # <span class='emph_1'>x</span>st-t akartunk írni, de nem sikerült

lst.append(200) <span class='big_black'># &#128163; (durr)</span>
</pre>
Ez is csak akkor derül ki, amikor xst pl. 100-as értéket kap. És ilyen hibát nagyon könnyû elkövetni.
</p>
<p>
<b style='font-size:200%;color:red;'>&#x261e;</b> <span class='emph_1'>TEHÁT: Sokkal, de sokkal</span> gondosabban kell tesztelni, mint a típusellenõrzéses
nyelveknél, gondoskodni kell róla, hogy minden ágat bejárjunk.
</p>
<p>
Másik tipikus hiba: kulcsszó-felülírás. Itt például elõállítunk egy dict nevû objektumot, ami azt eredményezi, hogy a továbbiakban nem tudjuk ezt a kulcsszót
használni egy dictionary létrehozására. A dict elvesztette kulcsszó jellegét.

<pre>
<span class='emph_1'>dict</span> = { 'A': 1 }
x = 100
#...
if x < 20:
    print(x)
else:
    y = dict()  <span class='big_black'># &#128163; (durr)</span>
</pre>

<b style='font-size:200%;color:red;'>&#x261e;</b> <span class='emph_1'>TEHÁT: Nagyon-nagyon rettentõen sokkal, de sokkal</span> gondosabban kell tesztelni, mint a
kompilált nyelveknél, gondoskodni kell róla, hogy minden ágat bejárjunk.
</p>
<p>
Az élesebb szemû olvasók talán sejtik már halványan, hogy az ilyen típusú hibákat és az ellenük való védekezést nagyon fontosnak tartom. És ha maguk is
kergettek már hasonló hibákat nagyobb programokban, akkor biztosan lelkesen bólogatnak. Továbbá nekik is számos õsz hajszáluk van.
</p>
<h3 id='no_declaration'>&rtrif; Deklaráció hiánya &rArr; még futás közben sem kiderülõ hibák</h3>
<p>
A változók akkor keletkeznek, amikor elõször értéket kapnak. Ha egy változónak értéket akarunk adni és elgépeljük a nevét, akkor létrejön egy új változó,
ami esetleg ott árválkodik és senki nem kíváncsi az értékére, miközben a program egészen másképpen viselkedik, mint ahogy kellene neki

<pre>
x = 10
#...
if x < 20:
   print('do something')
   <span class='emph_1'>y</span> = 100   # elgépelés <span class='emph_1'>x</span> = 100 helyett
#...
if x > 20:
   print('do something else') # ide sosem jutunk el
<div class='result'>
# do something
</div>
</pre>
x helyett véletlenül y-t írtunk, ami miatt egy program-ág soha nem hajtódik végre. Ez a legkegyetlenebb hiba: nincs szintaktikai probléma, csak az eredmények
lesznek néha hibásak.
</p>
<p>
<b style='font-size:200%;color:red;'>&#x261e;</b> <span class='emph_1'>TEHÁT: Nagyon-nagyon-<span style='font-size: 90%;'>nagyon-</span><span
style='font-size: 90%;'>nagyon-</span><span style='font-size: 80%;'>nagyon </span> <span style='font-size: 70%;'>de igazán,</span>
<span style='font-size: 50%;'>ne kelljen már mégegyszer elmondanom...</span></span>
</p>
<h3 id='no_private'>&rtrif; Nincsenek private és protected elemek</h3>
<p>
Osztályok definiálásakor nincs arra mód, hogy az adatrejtést <b>kikényszerítsük</b>, azaz hogy egyes attribútumok és metódusok hozzáférhetetlenek legyenek a
külvilág számára. Mi tagadás, ez hátrány, de azért nem nagyon nagy hendikep. Elnevezési konvenciókkal és docstring-ekkel világossá lehet tenni, hogy melyek
a private-nek vagy protected-nek szánt elemek &ndash; és bár a programozók tipikusan önfejû lények, de azért kevesen vannak köztük, akik szándékosan, tiltás
ellenére is rombolják a saját munkájukat. Azaz önhekkerek.
</p>
<h3 id='missing_constructs'>&rtrif; Nincs switch és nincs const</h3>
<p>
Számomra érthetetlen, miért maradt ki a nyelvbõl a switch (case) utasítás, amely a sokszoros if-else-eket kiváltaná. Idõnként nagyon hiányzik. Hasonlóan
hiányolom a konstansokat, amelyeket valamennyire lehet ugyan pótolni egyelemû tuple-lal, de azért nem egészen és ez körülményes is egy kicsit.
</p>
<h3 id='low_speed'>&rtrif; Lassúság?</h3>
<p>
Egy interpretált nyelv, amilyen a Python is, mindig lassúbb egy kompilált nyelvnél, mint amilyen például a C++, hiszen futás közben állítja elõ a
bytecode-ból a gépi kódot. A Pythonnál ehhez még hozzájön az, hogy mindent objektumnak tekint, még egy numerikus konstanst is, ezért az értékek elérése
tartalmaz egy járulékos indirekciót.
</p>
<p>
A jó hír viszont az, hogy ez a sebességkülönbség <b>nagyon</b> ritkán zavaró. Akár fájlból olvas a program, akár adatbázisból, akár hálózatról &ndash; ezek
a mûveletek sokkal lassúbbak a memória-mûveleteknél. A sebesség-különbség csak nagy mennyiségû numerikus számítás esetén válhat zavaróvá, viszont a numerikus
mûveletekhez használt modulokat (numpy, Numba) kifejezetten sebességre optimalizáltan alkották meg.
</p>
<p style='text-align:center; font-size: 300%;'>&spades;</p>
</body>
</html>
